# =============================================================================
# Azure DevOps Pipeline - Environment Vending
# =============================================================================
# This pipeline manages the workspace lifecycle for your application.
# It runs when environments.yaml or .vending/ files change.
#
# What it does:
#   1. Validates terraform configuration
#   2. Creates/updates TFC workspaces based on environments.yaml
#   3. Generates the deployment pipeline (azure-pipelines.yml) dynamically
# =============================================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - environments.yaml
      - .vending/**

pr:
  branches:
    include:
      - main
  paths:
    include:
      - environments.yaml
      - .vending/**

pool:
  vmImage: 'ubuntu-latest'

variables:
  - name: TF_VERSION
    value: '1.9.0'
  - name: TF_IN_AUTOMATION
    value: 'true'

stages:
  # ===========================================================================
  # Stage 1: Validate Vending Configuration
  # ===========================================================================
  - stage: ValidateVending
    displayName: 'Validate Vending'
    jobs:
      - job: Validate
        displayName: 'Format & Validate'
        steps:
          - task: TerraformInstaller@1
            inputs:
              terraformVersion: $(TF_VERSION)

          - script: terraform fmt -check -recursive -diff .vending/
            displayName: 'Terraform Format'

          - script: |
              cd .vending
              terraform init -backend=false
              terraform validate
            displayName: 'Terraform Validate'

  # ===========================================================================
  # Stage 2: Apply Vending (Create/Update Workspaces)
  # ===========================================================================
  - stage: ApplyVending
    displayName: 'Apply Vending'
    dependsOn: ValidateVending
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: Vend
        displayName: 'Create TFC Workspaces'
        steps:
          - task: TerraformInstaller@1
            inputs:
              terraformVersion: $(TF_VERSION)

          - bash: |
              # Extract APP_ID from repo name
              REPO_NAME="$(Build.Repository.Name)"
              # Get last part after /
              APP_ID=$(echo "$REPO_NAME" | rev | cut -d'/' -f1 | rev)
              # Remove terraform-azure-infra- prefix
              APP_ID=$(echo "$APP_ID" | sed 's/^terraform-azure-infra-//')
              echo "##vso[task.setvariable variable=APP_ID]$APP_ID"
              echo "Extracted APP_ID: $APP_ID"
            displayName: 'Extract App ID'

          - bash: |
              mkdir -p ~/.terraform.d
              cat > ~/.terraform.d/credentials.tfrc.json << EOF
              {
                "credentials": {
                  "app.terraform.io": {
                    "token": "$(TFC_TOKEN)"
                  }
                }
              }
              EOF
            displayName: 'Configure TFC'

          - bash: |
              echo "=============================================="
              echo "Vending: $(APP_ID)-vending"
              echo "=============================================="

              cd .vending
              export TF_WORKSPACE="$(APP_ID)-vending"
              terraform init
              terraform apply -auto-approve
            displayName: 'Apply Vending'

  # ===========================================================================
  # Stage 3: Generate Deployment Pipeline
  # ===========================================================================
  - stage: GeneratePipeline
    displayName: 'Generate Deployment Pipeline'
    dependsOn: ApplyVending
    condition: succeeded()
    jobs:
      - job: Generate
        displayName: 'Generate azure-pipelines.yml'
        steps:
          - checkout: self
            persistCredentials: true

          - bash: |
              # Extract APP_ID from repo name
              REPO_NAME="$(Build.Repository.Name)"
              APP_ID=$(echo "$REPO_NAME" | rev | cut -d'/' -f1 | rev | sed 's/^terraform-azure-infra-//')
              echo "##vso[task.setvariable variable=APP_ID]$APP_ID"
              echo "APP_ID: $APP_ID"
            displayName: 'Extract App ID'

          - bash: |
              pip install pyyaml -q
            displayName: 'Install PyYAML'

          - bash: |
              APP_ID="$(APP_ID)"

              # Generate the deployment pipeline using Python
              python3 << 'PYEOF'
              import yaml
              import os

              # Read environments configuration
              with open('environments.yaml', 'r') as f:
                  config = yaml.safe_load(f)

              environments = config.get('environments', [])
              enabled_envs = [e for e in environments if e.get('enabled', False)]

              app_id = os.environ.get('APP_ID', 'unknown')

              # Build the pipeline YAML
              pipeline = {
                  'trigger': {
                      'branches': {'include': ['main']},
                      'paths': {
                          'include': ['*.tf', 'modules/**'],
                          'exclude': ['.vending/**', 'environments.yaml', '*.md', 'docs/**']
                      }
                  },
                  'pr': {
                      'branches': {'include': ['main']},
                      'paths': {
                          'include': ['*.tf', 'modules/**'],
                          'exclude': ['.vending/**', 'environments.yaml']
                      }
                  },
                  'pool': {'vmImage': 'ubuntu-latest'},
                  'variables': [
                      {'group': f'{app_id}-secrets'},
                      {'name': 'TF_VERSION', 'value': '1.9.0'},
                      {'name': 'TF_IN_AUTOMATION', 'value': 'true'}
                  ],
                  'stages': []
              }

              # Add Quality Gates stage
              quality_gates = {
                  'stage': 'QualityGates',
                  'displayName': 'Quality Gates',
                  'jobs': [{
                      'job': 'Validate',
                      'displayName': 'Format & Validate',
                      'steps': [
                          {'task': 'TerraformInstaller@1', 'inputs': {'terraformVersion': '$(TF_VERSION)'}},
                          {'script': 'terraform fmt -check -recursive -diff', 'displayName': 'Terraform Format'},
                          {'script': 'terraform init -backend=false\nterraform validate', 'displayName': 'Terraform Validate'}
                      ]
                  }]
              }
              pipeline['stages'].append(quality_gates)

              # Add deployment stages for each enabled environment
              previous_stage = 'QualityGates'
              for env in enabled_envs:
                  name = env['name']
                  tier = env.get('tier', 'n')
                  env_code = env.get('environment_code', name[0])
                  sequence = env.get('sequence', '01')
                  workspace_suffix = f"{tier}1{env_code}{sequence}"
                  workspace_name = f"{app_id}{workspace_suffix}"

                  stage_name = f"Deploy{name.capitalize()}"
                  display_name = f"Deploy {name.upper()}"

                  # Build the stage
                  stage = {
                      'stage': stage_name,
                      'displayName': display_name,
                      'dependsOn': previous_stage,
                      'condition': "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))"
                  }

                  # Configure TFC script (same for all envs)
                  config_tfc_script = '''mkdir -p ~/.terraform.d
              cat > ~/.terraform.d/credentials.tfrc.json << EOF
              {"credentials":{"app.terraform.io":{"token":"$(TFC_TOKEN)"}}}
              EOF'''

                  # Apply script with hardcoded workspace name
                  apply_script = f'''echo "Deploying to workspace: {workspace_name}"
              export TF_WORKSPACE="{workspace_name}"
              terraform init
              terraform apply -auto-approve'''

                  # Use deployment job with environment for non-dev (requires approval)
                  if name == 'dev':
                      stage['jobs'] = [{
                          'job': name.capitalize(),
                          'displayName': f'Apply {name.upper()}',
                          'steps': [
                              {'task': 'TerraformInstaller@1', 'inputs': {'terraformVersion': '$(TF_VERSION)'}},
                              {'bash': config_tfc_script, 'displayName': 'Configure TFC'},
                              {'bash': apply_script, 'displayName': f'Apply {name.upper()}'}
                          ]
                      }]
                  else:
                      # Use deployment job with environment approval
                      env_name = 'Production' if name == 'prod' else name.upper()
                      stage['jobs'] = [{
                          'deployment': name.capitalize(),
                          'displayName': f'Apply {name.upper()}',
                          'environment': env_name,
                          'strategy': {
                              'runOnce': {
                                  'deploy': {
                                      'steps': [
                                          {'checkout': 'self'},
                                          {'task': 'TerraformInstaller@1', 'inputs': {'terraformVersion': '$(TF_VERSION)'}},
                                          {'bash': config_tfc_script, 'displayName': 'Configure TFC'},
                                          {'bash': apply_script, 'displayName': f'Apply {name.upper()}'}
                                      ]
                                  }
                              }
                          }
                      }]

                  pipeline['stages'].append(stage)
                  previous_stage = stage_name

              # If no environments enabled, add a placeholder stage
              if not enabled_envs:
                  pipeline['stages'].append({
                      'stage': 'NoEnvironments',
                      'displayName': 'No Environments Enabled',
                      'dependsOn': 'QualityGates',
                      'condition': "and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))",
                      'jobs': [{
                          'job': 'Info',
                          'displayName': 'Information',
                          'steps': [{
                              'script': 'echo "No environments are enabled. Edit environments.yaml to enable environments."',
                              'displayName': 'No Environments'
                          }]
                      }]
                  })

              # Write the pipeline file with header
              header = '''# =============================================================================
              # Azure DevOps Pipeline - Infrastructure Deployment (AUTO-GENERATED)
              # =============================================================================
              # THIS FILE IS AUTO-GENERATED BY THE VENDING PIPELINE
              # Do not edit manually - changes will be overwritten!
              #
              # To add/remove environments, edit environments.yaml and let the
              # vending pipeline regenerate this file.
              # =============================================================================

              '''
              # Fix header indentation
              header = '\n'.join(line.strip() for line in header.strip().split('\n')) + '\n\n'

              with open('azure-pipelines.yml', 'w') as f:
                  f.write(header)
                  yaml.dump(pipeline, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

              print(f"Generated azure-pipelines.yml with {len(enabled_envs)} environment(s)")
              for env in enabled_envs:
                  print(f"  - {env['name']}")
              PYEOF
            displayName: 'Generate Pipeline YAML'
            env:
              APP_ID: $(APP_ID)

          - bash: |
              # Check if there are changes to commit
              if git diff --quiet azure-pipelines.yml 2>/dev/null; then
                echo "No changes to azure-pipelines.yml"
                exit 0
              fi

              echo "Changes detected in azure-pipelines.yml"
              git config user.email "azure-pipelines@dev.azure.com"
              git config user.name "Azure Pipelines"

              git add azure-pipelines.yml
              git commit -m "chore: regenerate deployment pipeline from environments.yaml

              This commit was auto-generated by the vending pipeline."

              git push origin HEAD:main
            displayName: 'Commit Generated Pipeline'
